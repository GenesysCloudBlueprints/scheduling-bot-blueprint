/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of bookings
         * @description Retrieves a list of bookings.
         *
         *     The ability `booking:view` is required for this operation.
         *
         *     The ability `booking:protected_metadata` is required to read and filter by the property `protected_metadata`.
         */
        get: operations["getBookings"];
        put?: never;
        /**
         * Create a booking
         * @description Creates a booking.
         *
         *     The ability `booking:create` is required for this operation.
         *
         *     The ability `booking:protected_metadata` is required to set the property `protected_metadata` and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule`.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked`.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots`.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window`.
         *
         *     If the property `resource_id` is not provided in the request, a resource will be selected automatically based on the resource selection strategy of the location.
         *
         *     If the property `price` is not provided in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, the price of the booking will be set to `null`. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property.
         *
         *     If the properties `buffer_starts_at` or `buffer_ends_at` are not provided in the request, they will be calculated automatically based on the `buffer_time_before` and `buffer_time_after` properties of the service. To avoid this automatic behavior, you need to explicitly provide a value for the properties. If any of these properties are set to a value that doesn’t match the buffer time of the service, the use of the property `ignore_bookable_slots` is required, since the booking won’t match a bookable slot.
         */
        post: operations["postBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bookings/{booking}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking. */
                booking: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a booking
         * @description Retrieves the specified booking.
         *
         *     The ability `booking:view` is required for this operation.
         *
         *     The ability `booking:protected_metadata` is required to read the property `protected_metadata`.
         */
        get: operations["getBooking"];
        /**
         * Replace a booking
         * @description Replaces the specified booking with the booking provided in the request body.
         *
         *     The ability `booking:update` is required for this operation.
         *
         *     The ability `booking:protected_metadata` is required to update the property `protected_metadata` and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule`.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked`.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots`.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window`.
         *
         *     The ability `booking:ignore_cancelation_threshold` is required to use the property `ignore_cancelation_threshold`.
         *
         *     If the property `resource_id` is not provided in the request, a resource will be selected automatically based on the resource selection strategy of the location.
         *
         *     If the property `price` is not provided in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, or if the service has been deleted, the price of the booking will be set to `null`. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property.
         *
         *     If the properties `buffer_starts_at` or `buffer_ends_at` are not provided in the request, they will be calculated automatically based on the `buffer_time_before` and `buffer_time_after` properties of the service. To avoid this automatic behavior, you need to explicitly provide a value for the properties. If any of these properties are set to a value that doesn’t match the buffer time of the service, the use of the property `ignore_bookable_slots` is required, since the booking won’t match a bookable slot.
         */
        put: operations["putBooking"];
        post?: never;
        /**
         * Delete a booking
         * @description Deletes the specified booking.
         *
         *     The ability `booking:delete` is required for this operation.
         *
         *     Note that deleting a booking is a permanent action, and the deleted booking can’t be restored.
         */
        delete: operations["deleteBooking"];
        options?: never;
        head?: never;
        /**
         * Patch a booking
         * @description Patches the specified booking. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `booking:update` is required for this operation.
         *
         *     The ability `booking:protected_metadata` is required to patch the property `protected_metadata` and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule`.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked`.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots`.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window`.
         *
         *     The ability `booking:ignore_cancelation_threshold` is required to use the property `ignore_cancelation_threshold`.
         *
         *     If any of the properties `service_id`, `starts_at`, or `ends_at` is provided in the request, and its value differs from the original value on the booking, and the property `price` is not provided in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, the price of the booking will be set to `null`. If the service has been deleted, the price of the booking will be left untouched. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property `price`.
         *
         *     If the property `starts_at` is provided, and its value differs from the original value on the booking, and the property `buffer_starts_at` is not provided in the request, it will be calculated automatically based on the `buffer_time_before` property of the service. If the service has been deleted, the `buffer_starts_at` property will be set to the same value as `starts_at`. To avoid this automatic behavior, you need to explicitly provide a value for the property `buffer_starts_at`.
         *
         *     If the property `ends_at` is provided, and its value differs from the original value on the booking, and the property `buffer_ends_at` is not provided in the request, it will be calculated automatically based on the `buffer_time_after` property of the service. If the service has been deleted, the `buffer_ends_at` property will be set to the same value as `ends_at`. To avoid this automatic behavior, you need to explicitly provide a value for the property `buffer_ends_at`.
         */
        patch: operations["patchBooking"];
        trace?: never;
    };
    "/booking-groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of booking groups
         * @description Retrieves a list of booking groups.
         *
         *     The ability `booking_group:view` is required for this operation.
         *
         *     The ability `booking_group:protected_metadata` or `booking_group:read_protected_metadata` is required to read and filter by the property `protected_metadata` on the booking groups.
         *
         *     The ability `booking:protected_metadata` is required to read and filter by the property `protected_metadata` on the bookings included in the booking groups.
         *
         *     Note that for the filters, if any booking within the booking group matches the filters, that booking group is included in the response, including all of its bookings.
         */
        get: operations["getBookingGroups"];
        put?: never;
        /**
         * Create a booking group
         * @description Creates a booking group.
         *
         *     The ability `booking_group:create` is required for this operation.
         *
         *     The ability `booking_group:protected_metadata` or `booking_group:write_protected_metadata` is required to set the property `protected_metadata`.
         *
         *     The ability `booking:protected_metadata` is required to set the property `protected_metadata` on the bookings in the booking group and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule` on a booking in the booking group.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked` on a booking in the booking group.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots` on a booking in the booking group.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window` on a booking in the booking group.
         *
         *     If the property `resource_id` is not provided for a booking in the request, a resource will be selected automatically based on the resource selection strategy of the location.
         *
         *     If the property `price` is not provided for a booking in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, the price of the booking will be set to `null`. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property.
         *
         *     If the properties `buffer_starts_at` or `buffer_ends_at` are not provided for a booking in the request, they will be calculated automatically based on the `buffer_time_before` and `buffer_time_after` properties of the service. To avoid this automatic behavior, you need to explicitly provide a value for the properties. If any of these properties are set to a value that doesn’t match the buffer time of the service, the use of the property `ignore_bookable_slots` is required, since the booking won’t match a bookable slot.
         */
        post: operations["postBookingGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/booking-groups/{booking-group}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking group. */
                "booking-group": string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a booking group
         * @description Retrieves the specified booking group.
         *
         *     The ability `booking_group:view` is required for this operation.
         *
         *     The ability `booking_group:protected_metadata` or `booking_group:read_protected_metadata` is required to read the property `protected_metadata` of the booking group.
         *
         *     The ability `booking:protected_metadata` is required to read the property `protected_metadata` of the bookings in the booking group.
         */
        get: operations["getBookingGroup"];
        /**
         * Replace a booking group
         * @description Replaces the specified booking group with the booking group provided in the request body.
         *
         *     The ability `booking_group:update` is required for this operation.
         *
         *     The ability `booking_group:protected_metadata` or `booking_group:write_protected_metadata` is required to update the property `protected_metadata` of the booking group.
         *
         *     The ability `booking:protected_metadata` is required to update the property `protected_metadata` of the bookings in the booking group and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_cancelation_threshold` is required to use the property `ignore_cancelation_threshold` on the bookings in the booking group.
         *
         *     If the property `resource_id` is not provided for a booking in the request, a resource will be selected automatically based on the resource selection strategy of the location.
         *
         *     If the property `price` is not provided for a booking in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, or if the service has been deleted, the price of the booking will be set to `null`. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property.
         *
         *     If the properties `buffer_starts_at` or `buffer_ends_at` are not provided for a booking in the request, they will be calculated automatically based on the `buffer_time_before` and `buffer_time_after` properties of the service. To avoid this automatic behavior, you need to explicitly provide a value for the properties. If any of these properties are set to a value that doesn’t match the buffer time of the service, the use of the property `ignore_bookable_slots` is required, since the booking won’t match a bookable slot.
         */
        put: operations["putBookingGroup"];
        post?: never;
        /**
         * Delete a booking group
         * @description Deletes the specified booking group.
         *
         *     The ability `booking_group:delete` is required for this operation.
         *
         *     Note that deleting a booking group is a permanent action, and the deleted booking group and its bookings can’t be restored.
         */
        delete: operations["deleteBookingGroup"];
        options?: never;
        head?: never;
        /**
         * Patch a booking group
         * @description Patches the specified booking group. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `booking_group:update` is required for this operation.
         *
         *     The ability `booking_group:protected_metadata` or `booking_group:write_protected_metadata` is required to patch the property `protected_metadata` of the booking group.
         *
         *     The ability `booking:protected_metadata` is required to patch the property `protected_metadata` of the bookings in the booking group and include it in the response.
         *
         *     The ability `booking:ignore_schedule` is required to use the property `ignore_schedule` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_fully_booked` is required to use the property `ignore_fully_booked` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_bookable_slots` is required to use the property `ignore_bookable_slots` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_booking_window` is required to use the property `ignore_booking_window` on the bookings in the booking group.
         *
         *     The ability `booking:ignore_cancelation_threshold` is required to use the property `ignore_cancelation_threshold` on the bookings in the booking group.
         *
         *     If any of the properties `service_id`, `starts_at`, or `ends_at` is provided for a booking in the request, and its value differs from the original value on the booking, and the property `price` is not provided in the request, it will be calculated automatically based on the length of the booking and the price of the service. If the service doesn’t have a price, the price of the booking will be set to `null`. If the service has been deleted, the price of the booking will be left untouched. To avoid this automatic behavior, you need to explicitly provide a value or `null` for the property `price`.
         *
         *     If the property `starts_at` is provided for a booking, and its value differs from the original value on the booking, and the property `buffer_starts_at` is not provided for the booking in the request, it will be calculated automatically based on the `buffer_time_before` property of the service. If the service has been deleted, the `buffer_starts_at` property will be set to the same value as `starts_at`. To avoid this automatic behavior, you need to explicitly provide a value for the property `buffer_starts_at`.
         *
         *     If the property `ends_at` is provided for a booking, and its value differs from the original value on the booking, and the property `buffer_ends_at` is not provided for the booking in the request, it will be calculated automatically based on the `buffer_time_after` property of the service. If the service has been deleted, the `buffer_ends_at` property will be set to the same value as `ends_at`. To avoid this automatic behavior, you need to explicitly provide a value for the property `buffer_ends_at`.
         */
        patch: operations["patchBookingGroup"];
        trace?: never;
    };
    "/locations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of locations
         * @description Retrieves a list of locations.
         *
         *     The ability `location:view` is required for this operation.
         *
         *     The ability `location:protected_metadata` is required to read and filter by the property `protected_metadata`.
         */
        get: operations["getLocations"];
        put?: never;
        /**
         * Create a location
         * @description Creates a location.
         *
         *     The ability `location:create` is required for this operation.
         *
         *     The ability `location:protected_metadata` is required to set the property `protected_metadata` and include it in the response.
         */
        post: operations["postLocation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/locations/{location}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a location. */
                location: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a location
         * @description Retrieves the specified location.
         *
         *     The ability `location:view` is required for this operation.
         *
         *     The ability `location:protected_metadata` is required to read the property `protected_metadata`.
         */
        get: operations["getLocation"];
        /**
         * Replace a location
         * @description Replaces the specified location with the location provided in the request body.
         *
         *     The ability `location:update` is required for this operation.
         *
         *     The ability `location:protected_metadata` is required to update the property `protected_metadata` and include it in the response.
         */
        put: operations["putLocation"];
        post?: never;
        /**
         * Delete a location
         * @description Deletes the specified location.
         *
         *     The ability `location:delete` is required for this operation.
         *
         *     Note that deleting a location is a permanent action, and the deleted location can’t be restored. All bookings that are associated with the location will be left without any location associated with them (i.e. the properties `location_id` and `location` of the bookings will be `null`). If you have a location that should no longer be available for bookings, but you want to keep it associated with existing bookings, you can disable the location by setting the property `enabled` to `false`.
         */
        delete: operations["deleteLocation"];
        options?: never;
        head?: never;
        /**
         * Patch a location
         * @description Patches the specified location. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `location:update` is required for this operation.
         *
         *     The ability `location:protected_metadata` is required to patch the property `protected_metadata` and include it in the response.
         */
        patch: operations["patchLocation"];
        trace?: never;
    };
    "/project": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve your project
         * @description Retrieves the project that the API token of the request is associated with.
         */
        get: operations["getYourProject"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of resources
         * @description Retrieves a list of resources.
         *
         *     The ability `resource:view` is required for this operation.
         *
         *     The ability `resource:protected_metadata` is required to read and filter by the property `protected_metadata`.
         */
        get: operations["getResources"];
        put?: never;
        /**
         * Create a resource
         * @description Creates a resource.
         *
         *     The ability `resource:create` is required for this operation.
         *
         *     The ability `resource:protected_metadata` is required to set the property `protected_metadata` and include it in the response.
         */
        post: operations["postResource"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a resource
         * @description Retrieves the specified resource.
         *
         *     The ability `resource:view` is required for this operation.
         *
         *     The ability `resource:protected_metadata` is required to read the property `protected_metadata`.
         */
        get: operations["getResource"];
        /**
         * Replace a resource
         * @description Replaces the specified resource with the resource provided in the request body.
         *
         *     The ability `resource:update` is required for this operation.
         *
         *     The ability `resource:protected_metadata` is required to update the property `protected_metadata` and include it in the response.
         */
        put: operations["putResource"];
        post?: never;
        /**
         * Delete a resource
         * @description Deletes the specified resource.
         *
         *     The ability `resource:delete` is required for this operation.
         *
         *     Note that deleting a resource is a permanent action, and the deleted resource can’t be restored. All schedule blocks, recurring schedules, and recurring schedule blocks for the resource will be deleted as well. All bookings that are associated with the resource will be left without any resource associated with them (i.e. the properties `resource_id` and `resource` of the bookings will be `null`). If you have a resource that should no longer be available for bookings, you can disable the resource by setting the property `enabled` to `false`.
         */
        delete: operations["deleteResource"];
        options?: never;
        head?: never;
        /**
         * Patch a resource
         * @description Patches the specified resource. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `resource:update` is required for this operation.
         *
         *     The ability `resource:protected_metadata` is required to patch the property `protected_metadata` and include it in the response.
         */
        patch: operations["patchResource"];
        trace?: never;
    };
    "/resources/{resource}/schedule-blocks": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of schedule blocks
         * @description Retrieves a list of schedule blocks for a resource.
         *
         *     The ability `schedule_block:view` is required for this operation.
         */
        get: operations["getResourceScheduleBlocks"];
        put?: never;
        /**
         * Create a schedule block
         * @description Creates a schedule block for a resource.
         *
         *     The ability `schedule_block:create` is required for this operation.
         *
         *     The time offset of the properties `starts_at` and `ends_at` will be converted to the time offset of the time zone of the location of the schedule block.
         *
         *     If the schedule block overlaps with an existing schedule block for the resource at the same location and with the same availability, the schedule block won’t be created, and a `422 Unprocessable Entity` response will be returned.
         */
        post: operations["postResourceScheduleBlock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/schedule-blocks/{schedule-block}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a schedule block
         * @description Retrieves the specified schedule block for a resource.
         *
         *     The ability `schedule_block:view` is required for this operation.
         */
        get: operations["getResourceScheduleBlock"];
        /**
         * Replace a schedule block
         * @description Replaces the specified schedule block for a resource with the schedule block provided in the request body.
         *
         *     The ability `schedule_block:update` is required for this operation.
         *
         *     The time offset of the properties `starts_at` and `ends_at` will be converted to the time offset of the time zone of the location of the schedule block.
         *
         *     If the new schedule block overlaps with an existing schedule block for the resource at the same location and with the same availability, the schedule block won’t be replaced, and a `422 Unprocessable Entity` response will be returned.
         */
        put: operations["putResourceScheduleBlock"];
        post?: never;
        /**
         * Delete a schedule block
         * @description Deletes the specified schedule block for a resource.
         *
         *     The ability `schedule_block:delete` is required for this operation.
         *
         *     Note that deleting a schedule block is a permanent action, and the deleted schedule block can’t be restored.
         */
        delete: operations["deleteResourceScheduleBlock"];
        options?: never;
        head?: never;
        /**
         * Patch a schedule block
         * @description Patches the specified schedule block for a resource. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `schedule_block:update` is required for this operation.
         *
         *     The time offset of the properties `starts_at` and `ends_at` will be converted to the time offset of the time zone of the location of the schedule block.
         *
         *     If the patched schedule block overlaps with an existing schedule block for the resource at the same location and with the same availability, the schedule block won’t be patched, and a `422 Unprocessable Entity` response will be returned.
         */
        patch: operations["patchResourceScheduleBlock"];
        trace?: never;
    };
    "/resources/{resource}/recurring-schedules": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of recurring schedules
         * @description Retrieves a list of recurring schedules for a resource.
         *
         *     The ability `recurring_schedule:view` is required for this operation.
         */
        get: operations["getResourceRecurringSchedules"];
        put?: never;
        /**
         * Create a recurring schedule
         * @description Creates a recurring schedule for a resource.
         *
         *     The ability `recurring_schedule:create` is required for this operation.
         *
         *     The date values of the properties `start_date` and `end_date` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     Note that if multiple recurring schedules are active at the same time for the same resource and location, all of them will be included when dynamically building the schedule for that resource at that location. To avoid this, the properties `start_date` and `end_date` need to be set so that the recurring schedules don’t overlap.
         */
        post: operations["postResourceRecurringSchedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/recurring-schedules/{recurring-schedule}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a recurring schedule
         * @description Retrieves the specified recurring schedule for a resource.
         *
         *     The ability `recurring_schedule:view` is required for this operation.
         */
        get: operations["getResourceRecurringSchedule"];
        /**
         * Replace a recurring schedule
         * @description Replaces the specified recurring schedule for a resource with the recurring schedule provided in the request body.
         *
         *     The ability `recurring_schedule:update` is required for this operation.
         *
         *     The date values of the properties `start_date` and `end_date` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     Note that if multiple recurring schedules are active at the same time for the same resource and location, all of them will be included when dynamically building the schedule for that resource at that location. To avoid this, the properties `start_date` and `end_date` need to be set so that the recurring schedules don’t overlap.
         */
        put: operations["putResourceRecurringSchedule"];
        post?: never;
        /**
         * Delete a recurring schedule
         * @description Deletes the specified recurring schedule for a resource.
         *
         *     The ability `recurring_schedule:delete` is required for this operation.
         *
         *     Note that deleting a recurring schedule is a permanent action, and the deleted recurring schedule can’t be restored. All recurring schedule blocks that belongs to the recurring schedule will be deleted as well.
         */
        delete: operations["deleteResourceRecurringSchedule"];
        options?: never;
        head?: never;
        /**
         * Patch a recurring schedule
         * @description Patches the specified recurring schedule for a resource. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `recurring_schedule:update` is required for this operation.
         *
         *     The date values of the properties `start_date` and `end_date` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     Note that if multiple recurring schedules are active at the same time for the same resource and location, all of them will be included when dynamically building the schedule for that resource at that location. To avoid this, the properties `start_date` and `end_date` need to be set so that the recurring schedules don’t overlap.
         */
        patch: operations["patchResourceRecurringSchedule"];
        trace?: never;
    };
    "/resources/{resource}/recurring-schedules/{recurring-schedule}/schedule-blocks": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of recurring schedule blocks
         * @description Retrieves a list of recurring schedule blocks for a resource.
         *
         *     The ability `recurring_schedule_block:view` is required for this operation.
         */
        get: operations["getResourceRecurringScheduleBlocks"];
        put?: never;
        /**
         * Create a recurring schedule block
         * @description Creates a recurring schedule block for a resource.
         *
         *     The ability `recurring_schedule_block:create` is required for this operation.
         *
         *     The time values of the properties `start_time` and `end_time` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     If the recurring schedule block overlaps with an existing schedule block for the recurring schedule, the recurring schedule block won’t be created, and a `422 Unprocessable Entity` response will be returned.
         */
        post: operations["postResourceRecurringScheduleBlock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/recurring-schedules/{recurring-schedule}/schedule-blocks/{schedule-block}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
                /** @description The ID of a recurring schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a recurring schedule block
         * @description Retrieves the specified recurring schedule block for a resource.
         *
         *     The ability `recurring_schedule_block:view` is required for this operation.
         */
        get: operations["getResourceRecurringScheduleBlock"];
        /**
         * Replace a recurring schedule block
         * @description Replaces the specified recurring schedule block for a resource with the recurring schedule block provided in the request body.
         *
         *     The ability `recurring_schedule_block:update` is required for this operation.
         *
         *     The time values of the properties `start_time` and `end_time` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     If the new recurring schedule block overlaps with an existing schedule block for the recurring schedule, the recurring schedule block won’t be replaced, and a `422 Unprocessable Entity` response will be returned.
         */
        put: operations["putResourceRecurringScheduleScheduleBlock"];
        post?: never;
        /**
         * Delete a recurring schedule block
         * @description Deletes the specified recurring schedule block for a resource.
         *
         *     The ability `recurring_schedule_block:delete` is required for this operation.
         *
         *     Note that deleting a recurring schedule block is a permanent action, and the deleted recurring schedule block can’t be restored.
         */
        delete: operations["deleteResourceRecurringScheduleBlock"];
        options?: never;
        head?: never;
        /**
         * Patch a recurring schedule block
         * @description Patches the specified recurring schedule block for a resource. Any properties that are not provided in the request will be left untouched.
         *
         *     The ability `recurring_schedule_block:update` is required for this operation.
         *
         *     The time values of the properties `start_time` and `end_time` will be interpreted using the time zone of the location of the recurring schedule.
         *
         *     If the patched recurring schedule block overlaps with an existing schedule block for the recurring schedule, the recurring schedule block won’t be patched, and a `422 Unprocessable Entity` response will be returned.
         */
        patch: operations["patchResourceRecurringScheduleScheduleBlock"];
        trace?: never;
    };
    "/resources/{resource}/schedule": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve the schedule for a resource
         * @description Retrieves the schedule for the specified resource. The schedule is a list of time spans during which the resource is (or was) available for bookings. The schedule is dynamically created based on the schedule blocks and the recurring schedules for the resource at the location. Using the query parameter `fully_booked`, time spans when the resource is fully booked can either be excluded or included.
         *
         *     The ability `schedule:view` is required for this operation.
         */
        get: operations["getResourceSchedule"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/fully-booked": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve the fully booked time spans for a resource
         * @description Retrieves the fully booked time spans for the specified resource.
         *
         *     The ability `schedule:view` is required for this operation.
         */
        get: operations["getResourceFullyBooked"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/services": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of associated services for a resource
         * @description Retrieves a list of associations between services and the specified resource.
         *
         *     The ability `resource_service:view` is required for this operation.
         */
        get: operations["getResourceServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resource}/services/{service}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve an association between a service and a resource
         * @description Retrieves an association between a resource and a service.
         *
         *     The ability `resource_service:view` is required for this operation.
         */
        get: operations["getResourceService"];
        /**
         * Associate a service with a resource
         * @description Associates the specified service with the specified resource.
         *
         *     The ability `resource_service:create` is required for this operation.
         */
        put: operations["putResourceService"];
        post?: never;
        /**
         * Dissociate a service from a resource
         * @description Dissociates the specified service from the specified resource.
         *
         *     The ability `resource_service:delete` is required for this operation.
         */
        delete: operations["deleteResourceService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of services
         * @description Retrieves a list of services.
         *
         *     The ability `service:view` is required for this operation.
         *
         *     The ability `service:protected_metadata` is required to read and filter by the property `protected_metadata`.
         *
         *     Any properties that are not applicable to the type of the service will not be included.
         */
        get: operations["getServices"];
        put?: never;
        /**
         * Create a service
         * @description Creates a service.
         *
         *     The ability `service:create` is required for this operation.
         *
         *     The ability `service:protected_metadata` is required to set the property `protected_metadata` and include it in the response.
         *
         *     Any properties that are not applicable to the type of the service does not need to be provided in the request, and will be ignored if they are. Such properties will not be included in the response.
         */
        post: operations["postService"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{service}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a service
         * @description Retrieves the specified service.
         *
         *     The ability `service:view` is required for this operation.
         *
         *     The ability `service:protected_metadata` is required to read the property `protected_metadata`.
         *
         *     Any properties that are not applicable to the type of the service will not be included.
         */
        get: operations["getService"];
        /**
         * Replace a service
         * @description Replaces the specified service with the service provided in the request body.
         *
         *     The ability `service:update` is required for this operation.
         *
         *     The ability `service:protected_metadata` is required to update the property `protected_metadata` and include it in the response.
         *
         *     Any properties that are not applicable to the type of the service does not need to be provided in the request, and will be ignored if they are. Such properties will not be included in the response.
         */
        put: operations["putService"];
        post?: never;
        /**
         * Delete a service
         * @description Deletes the specified service.
         *
         *     The ability `service:delete` is required for this operation.
         *
         *     Note that deleting a service is a permanent action, and the deleted service can’t be restored. All bookings that are associated with the service will be left without any service associated with them (i.e. the properties `service_id` and `service` of the bookings will be `null`). If you have a service that should no longer be available for bookings, you can disable the service by setting the property `enabled` to `false`.
         */
        delete: operations["deleteService"];
        options?: never;
        head?: never;
        /**
         * Patch a service
         * @description Patches the specified service. Any properties that are not provided in the request will be left untouched. If the property `type` is changed from its original value, the properties that are required for the new type must be provided in the request as well.
         *
         *     The ability `service:update` is required for this operation.
         *
         *     The ability `service:protected_metadata` is required to patch the property `protected_metadata` and include it in the response.
         *
         *     Any properties that are not applicable to the type of the service will be ignored if they are provided in the request. Such properties will not be included in the response.
         */
        patch: operations["patchService"];
        trace?: never;
    };
    "/services/{service}/bookable-slots": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                service: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of bookable slots for a service
         * @description Retrieves a list of bookable slots for the specified service.
         *
         *     The ability `bookable_slot:view` is required for this operation.
         */
        get: operations["getServiceBookableSlots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{service}/resources": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                service: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve a list of associated resources for a service
         * @description Retrieves a list of associations between resources and the specified service.
         *
         *     The ability `resource_service:view` is required for this operation.
         */
        get: operations["getServiceResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{service}/resources/{resource}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        /**
         * Retrieve an association between a resource and a service
         * @description Retrieves an association between a resource and a service.
         *
         *     The ability `resource_service:view` is required for this operation.
         */
        get: operations["getServiceResource"];
        /**
         * Associate a resource with a service
         * @description Associates the specified resource with the specified service.
         *
         *     The ability `resource_service:create` is required for this operation.
         */
        put: operations["putServiceResource"];
        post?: never;
        /**
         * Dissociate a resource from a service
         * @description Dissociates the specified resource from the specified service.
         *
         *     The ability `resource_service:delete` is required for this operation.
         */
        delete: operations["deleteServiceResource"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Bookable slot (fixed) */
        BookableSlotFixed: components["schemas"]["BookableSlot"];
        /** Bookable slot (flexible) */
        BookableSlotFlexible: components["schemas"]["BookableSlotFixed"] & {
            /**
             * Format: date-time
             * @description The earliest timestamp when the bookable slot can end. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly min_ends_at?: string;
            /**
             * Format: date-time
             * @description The earliest timestamp when the buffer for the bookable slot ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly min_buffer_ends_at?: string;
        };
        /** Bookable slot (day) */
        BookableSlotDay: components["schemas"]["BookableSlotFlexible"];
        /** Bookable slot */
        BookableSlot: {
            /**
             * Format: date-time
             * @description The timestamp when the buffer for the bookable slot starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the bookable slot starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the bookable slot ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly ends_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer for the bookable slot ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly buffer_ends_at?: string;
            /** @description The resources that are available for the bookable slot. */
            readonly resources?: components["schemas"]["Resource"][];
        };
        /** Booking */
        Booking: {
            /**
             * Format: uuid
             * @description The ID of the booking.
             */
            readonly id?: string;
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking.
             */
            resource_id: string | null;
            /** @description The resource associated with the booking. */
            readonly resource?: components["schemas"]["Resource"] | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id: string | null;
            /** @description The service associated with the booking. */
            readonly service?: Omit<components["schemas"]["Service"], "type"> | null;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id: string | null;
            /** @description The location associated with the booking. */
            readonly location?: components["schemas"]["Location"] | null;
            /**
             * Format: uuid
             * @description The ID of the booking group the booking belongs to.
             */
            booking_group_id?: string | null;
            /** @description The booking group the booking belongs to. */
            readonly booking_group?: components["schemas"]["BookingGroupEmbedded"] | null;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * @description Whether the booking is canceled.
             * @default false
             */
            is_canceled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If there is no buffer time, this will have the same value as `starts_at`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If there is no buffer time, this will have the same value as `ends_at`.This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was finalized, i.e. when `is_temporary` was changed from `true` to `false`. If the booking was created with `is_temporary` set to `false`, this will have the same value as `created_at`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly finalized_at?: string | null;
            /**
             * Format: date-time
             * @description The timestamp when the booking was canceled, i.e. when `is_canceled` was changed from `false` to `true`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly canceled_at?: string | null;
        };
        /** Booking */
        BookingPatch: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking.
             */
            resource_id?: string;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id?: string;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id?: string;
            /**
             * Format: uuid
             * @description The ID of the booking group the booking belongs to.
             */
            booking_group_id?: string;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /** @description Whether the booking is temporary (i.e. not finalized). */
            is_temporary?: boolean;
            /** @description Whether the booking is canceled. */
            is_canceled?: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be updated even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be updated even if it would result in the resource being overbooked. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be updated even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be updated even if it is outside the booking window for the service. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_booking_window: boolean;
            /**
             * @description Whether to ignore the cancelation threshold for the service of the booking when canceling the booking.
             * @default false
             */
            ignore_cancelation_threshold: boolean;
        };
        /** Booking */
        BookingPost: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking. If no resource ID is provided, Hapio will automatically select an available resource (if there is one).
             */
            resource_id?: string | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id: string;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id: string;
            /**
             * Format: uuid
             * @description The ID of the booking group the booking belongs to.
             */
            booking_group_id?: string | null;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If this is not provided, it will be set automatically based on the property `buffer_time_before` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If this is not provided, it will be set automatically based on the property `buffer_time_after` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be created even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be created even if it would result in the resource being overbooked.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be created even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be created even if it is outside the booking window for the service.
             * @default false
             */
            ignore_booking_window: boolean;
        };
        /** Booking */
        BookingPut: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking. This can only be set to `null` when that is the current value.
             */
            resource_id: string | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking. This can only be set to `null` when that is the current value.
             */
            service_id: string | null;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking. This can only be set to `null` when that is the current value.
             */
            location_id: string | null;
            /**
             * Format: uuid
             * @description The ID of the booking group the booking belongs to.
             */
            booking_group_id?: string | null;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * @description Whether the booking is canceled.
             * @default false
             */
            is_canceled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If this is not provided, it will be set automatically based on the property `buffer_time_before` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If this is not provided, it will be set automatically based on the property `buffer_time_after` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be replaced even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be replaced even if it would result in the resource being overbooked.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be replaced even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be replaced even if it is outside the booking window for the service.
             * @default false
             */
            ignore_booking_window: boolean;
            /**
             * @description Whether to ignore the cancelation threshold for the service of the booking when canceling the booking.
             * @default false
             */
            ignore_cancelation_threshold: boolean;
        };
        /** Booking */
        BookingEmbedded: {
            /**
             * Format: uuid
             * @description The ID of the booking.
             */
            readonly id?: string;
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking.
             */
            resource_id: string | null;
            /** @description The resource associated with the booking. */
            readonly resource?: components["schemas"]["Resource"] | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id: string | null;
            /** @description The service associated with the booking. */
            readonly service?: Omit<components["schemas"]["Service"], "type"> | null;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id: string | null;
            /** @description The location associated with the booking. */
            readonly location?: components["schemas"]["Location"] | null;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * @description Whether the booking is canceled.
             * @default false
             */
            is_canceled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If there is no buffer time, this will have the same value as `starts_at`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If there is no buffer time, this will have the same value as `ends_at`.This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking was finalized, i.e. when `is_temporary` was changed from `true` to `false`. If the booking was created with `is_temporary` set to `false`, this will have the same value as `created_at`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly finalized_at?: string | null;
            /**
             * Format: date-time
             * @description The timestamp when the booking was canceled, i.e. when `is_canceled` was changed from `false` to `true`. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly canceled_at?: string | null;
        };
        /** Booking */
        BookingPatchEmbedded: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking.
             */
            resource_id?: string;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id?: string;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id?: string;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /** @description Whether the booking is temporary (i.e. not finalized). */
            is_temporary?: boolean;
            /** @description Whether the booking is canceled. */
            is_canceled?: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be updated even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be updated even if it would result in the resource being overbooked. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be updated even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be updated even if it is outside the booking window for the service. This property will only have an effect if any of the following properties are changed and the booking is not canceled: `starts_at`, `ends_at`, `buffer_starts_at`, `buffer_ends_at`, `resource_id`, `service_id`, `location_id`, `is_canceled`.
             * @default false
             */
            ignore_booking_window: boolean;
            /**
             * @description Whether to ignore the cancelation threshold for the service of the booking when canceling the booking.
             * @default false
             */
            ignore_cancelation_threshold: boolean;
        };
        /** Booking */
        BookingPostEmbedded: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking. If no resource ID is provided, Hapio will automatically select an available resource (if there is one).
             */
            resource_id?: string | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking.
             */
            service_id: string;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking.
             */
            location_id: string;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If this is not provided, it will be set automatically based on the property `buffer_time_before` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If this is not provided, it will be set automatically based on the property `buffer_time_after` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be created even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be created even if it would result in the resource being overbooked.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be created even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be created even if it is outside the booking window for the service.
             * @default false
             */
            ignore_booking_window: boolean;
        };
        /** Booking */
        BookingPutEmbedded: {
            /**
             * Format: uuid
             * @description The ID of the resource associated with the booking. This can only be set to `null` when that is the current value.
             */
            resource_id: string | null;
            /**
             * Format: uuid
             * @description The ID of the service associated with the booking. This can only be set to `null` when that is the current value.
             */
            service_id: string | null;
            /**
             * Format: uuid
             * @description The ID of the location associated with the booking. This can only be set to `null` when that is the current value.
             */
            location_id: string | null;
            /** @description The price of the booking. */
            price?: string | null;
            /** @description Metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the booking is temporary (i.e. not finalized).
             * @default false
             */
            is_temporary: boolean;
            /**
             * @description Whether the booking is canceled.
             * @default false
             */
            is_canceled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the bookings starts (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking ends (excluding any buffer time). This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time starts. If this is not provided, it will be set automatically based on the property `buffer_time_before` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the buffer time ends. If this is not provided, it will be set automatically based on the property `buffer_time_after` on the service. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            buffer_ends_at?: string;
            /**
             * @description Whether to ignore the schedule of the resource associated with the booking. Setting this to `true` forces the booking to be replaced even if it’s outside the schedule of the resource. When this is set to `true`, the property `ignore_bookable_slots` will also be set to `true`.
             * @default false
             */
            ignore_schedule: boolean;
            /**
             * @description Whether to ignore if the resource is fully booked. Setting this to `true` forces the booking to be replaced even if it would result in the resource being overbooked.
             * @default false
             */
            ignore_fully_booked: boolean;
            /**
             * @description Whether to ignore the bookable slots for the resource. Setting this to `true` forces the booking to be replaced even if it doesn’t match one of the bookable slots for the resource. This will automatically be set to `true` when `ignore_schedule` is set to `true`.
             * @default false
             */
            ignore_bookable_slots: boolean;
            /**
             * @description Whether to ignore the booking window for the service. Setting this to `true` forces the booking to be replaced even if it is outside the booking window for the service.
             * @default false
             */
            ignore_booking_window: boolean;
            /**
             * @description Whether to ignore the cancelation threshold for the service of the booking when canceling the booking.
             * @default false
             */
            ignore_cancelation_threshold: boolean;
        };
        /** Booking group */
        BookingGroup: {
            /**
             * Format: uuid
             * @description The ID of the booking group.
             */
            readonly id?: string;
            /** @description The bookings that belong to the booking group. */
            readonly bookings: components["schemas"]["BookingEmbedded"][];
            /** @description Metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * Format: date-time
             * @description The timestamp when the booking group was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking group was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Booking group */
        BookingGroupEmbedded: {
            /**
             * Format: uuid
             * @description The ID of the booking group.
             */
            readonly id?: string;
            /** @description Metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * Format: date-time
             * @description The timestamp when the booking group was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the booking group was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Booking group */
        BookingGroupPatch: {
            /** @description The bookings that belong to the booking group. If this is not included, all existing bookings within the group will be kept as they are. If this is included, any existing bookings within the booking group that are not included in this array will be deleted. */
            bookings?: ({
                /**
                 * Format: uuid
                 * @description The ID of the booking to patch. If no booking ID is provided, a new booking will be created. If a booking ID is provided, but no other fields for the booking, the booking will be kept as it is.
                 */
                id?: string;
            } & components["schemas"]["BookingPatchEmbedded"])[];
            /** @description Metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
        };
        /** Booking group */
        BookingGroupPost: {
            /** @description The bookings that belong to the booking group. */
            bookings: components["schemas"]["BookingPostEmbedded"][];
            /** @description Metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
        };
        /** Booking group */
        BookingGroupPut: {
            /** @description The bookings that belong to the booking group. Any existing bookings within the booking group that are not included in this array will be deleted. */
            bookings: ({
                /**
                 * Format: uuid
                 * @description The ID of the booking to replace. If no booking ID is provided, a new booking will be created.
                 */
                id?: string;
            } & components["schemas"]["BookingPutEmbedded"])[];
            /** @description Metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the booking group. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
        };
        /** Error */
        Error: {
            /** @description The human readable error message. */
            readonly message?: string;
        };
        /** Validation error */
        ValidationError: {
            /** @description The human readable error message. */
            readonly message?: string;
            /** @description An object with validation errors. */
            readonly errors?: Record<string, never>;
        };
        /** Booking group error */
        BookingGroupError: {
            /** @description The human readable error messages. */
            readonly messages?: Record<string, never>;
        };
        /** Location */
        Location: {
            /**
             * Format: uuid
             * @description The ID of the location.
             */
            readonly id?: string;
            /** @description The name of the location. */
            name: string;
            /**
             * @description The name of the time zone of the location. The name must be valid according to the IANA time zone database.
             * @example Europe/Stockholm
             */
            time_zone: string;
            /**
             * @description The strategy that should be used when Hapio automatically assigns a resource for a booking at this location. This will only be used when a booking is created without a specified resource.
             *
             *     The strategy `randomize` will randomly select an available resource.
             *
             *     The strategy `prioritize` will select the first available resource on the ordered list of resources specified in the property `resource_selection_priority`.
             *
             *     The strategy `equalize` will select the available resource that has the least booked time during the day the booking starts. If multiple resources are tied for the least booked time, one of them will be selected at random.
             * @enum {string}
             */
            resource_selection_strategy: "randomize" | "prioritize" | "equalize";
            /** @description The ordered priority list of resource IDs for the location. Only applicable to locations with the resource selection strategy `prioritize`.
             *
             *     Any resources that are available for bookings at the location, but are not on this list, will be prioritized according to their IDs in alphanumerical order after all resources on this list. */
            resource_selection_priority?: string[];
            /** @description Metadata associated with the location. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the location. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the location is enabled.
             * @default true
             */
            enabled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the location was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the location was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Location */
        LocationPatch: {
            /** @description The name of the location. */
            name?: string;
            /**
             * @description The name of the time zone of the location. The name must be valid according to the IANA time zone database.
             * @example Europe/Stockholm
             */
            time_zone?: string;
            /**
             * @description The strategy that should be used when Hapio automatically assigns a resource for a booking at this location. This will only be used when a booking is created without a specified resource.
             *
             *     The strategy `randomize` will randomly select an available resource.
             *
             *     The strategy `prioritize` will select the first available resource on the ordered list of resources specified in the property `resource_selection_priority`.
             *
             *     The strategy `equalize` will select the available resource that has the least booked time during the day the booking starts. If multiple resources are tied for the least booked time, one of them will be selected at random.
             * @enum {string}
             */
            resource_selection_strategy?: "randomize" | "prioritize" | "equalize";
            /** @description The ordered priority list of resource IDs for the location. Only applicable to locations with the resource selection strategy `prioritize`.
             *
             *     Any resources that are available for bookings at the location, but are not on this list, will be prioritized according to their IDs in alphanumerical order after all resources on this list. */
            resource_selection_priority?: string[];
            /** @description Metadata associated with the location. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the location. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /** @description Whether the location is enabled. */
            enabled?: boolean;
        };
        /** Project */
        Project: {
            /**
             * Format: uuid
             * @description The ID of the project.
             */
            readonly id?: string;
            /** @description The name of the project. */
            name: string;
            /**
             * @description Whether the project is enabled.
             * @default true
             */
            enabled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the project was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the project was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Recurring schedule */
        RecurringSchedule: {
            /**
             * Format: uuid
             * @description The ID of the recurring schedule.
             */
            readonly id?: string;
            /**
             * Format: uuid
             * @description The ID of the location that the recurring schedule applies to.
             */
            location_id: string;
            /** @description The location that the recurring schedule applies to. */
            readonly location?: components["schemas"]["Location"];
            /**
             * Format: date
             * @description The date when the recurring schedule takes effect. This date is formatted in ISO 8601 format: `YYYY-MM-DD`.
             */
            start_date: string;
            /**
             * Format: date
             * @description The date when the recurring schedule expires. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DD`. If this is `null`, the recurring schedule has no defined expiration date, and will continue indefinitely.
             * @default null
             */
            end_date: string | null;
            /**
             * @description The interval that the recurring schedule should repeat at. For example, `1` means that the recurring schedule is repeated every week, `3` means that it is repeated every third week and so on.
             * @default 1
             */
            interval: number;
            /**
             * Format: date-time
             * @description The timestamp when the recurring schedule was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the recurring schedule was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Recurring schedule block */
        RecurringScheduleBlock: {
            /**
             * Format: uuid
             * @description The ID of the recurring schedule block.
             */
            readonly id?: string;
            /**
             * @description The weekday of the recurring schedule block.
             * @enum {string}
             */
            weekday: "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
            /**
             * Format: time
             * @description The start time of the recurring schedule block. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            start_time: string;
            /**
             * Format: time
             * @description The end time of the recurring schedule block. This time is formatted in ISO 8601 format: `hh:mm:ss`, with the exception that 24:00:00 is allowed.
             */
            end_time: string;
            /**
             * Format: date-time
             * @description The timestamp when the recurring schedule block was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the recurring schedule block was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Recurring schedule block */
        RecurringScheduleBlockPatch: {
            /**
             * @description The weekday of the recurring schedule block.
             * @enum {string}
             */
            weekday?: "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
            /**
             * Format: time
             * @description The start time of the recurring schedule block. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            start_time?: string;
            /**
             * Format: time
             * @description The end time of the recurring schedule block. This time is formatted in ISO 8601 format: `hh:mm:ss`, with the exception that 24:00:00 is allowed.
             */
            end_time?: string;
        };
        /** Recurring schedule */
        RecurringSchedulePatch: {
            /**
             * Format: uuid
             * @description The ID of the location that the recurring schedule applies to.
             */
            location_id?: string;
            /**
             * Format: date
             * @description The date when the recurring schedule takes effect. This date is formatted in ISO 8601 format: `YYYY-MM-DD`.
             */
            start_date?: string;
            /**
             * Format: date
             * @description The date when the recurring schedule expires. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DD`.
             */
            end_date?: string | null;
            /** @description The interval that the recurring schedule should repeat at. For example, `1` means that the recurring schedule is repeated every week, `3` means that it is repeated every third week and so on. */
            interval?: number;
        };
        /** Resource */
        Resource: {
            /**
             * Format: uuid
             * @description The ID of the resource.
             */
            readonly id?: string;
            /** @description The name of the resource. */
            name: string;
            /**
             * @description The maximum number of bookings this resource can handle simultaneously. If this is `null`, the resource has no limit on the number of simultaneous bookings.
             * @default null
             */
            max_simultaneous_bookings: number | null;
            /** @description Metadata associated with the resource. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the resource. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /**
             * @description Whether the resource is enabled.
             * @default true
             */
            enabled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the resource was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the resource was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Resource */
        ResourcePatch: {
            /** @description The name of the resource. */
            name?: string;
            /** @description The maximum number of bookings this resource can handle simultaneously. If this is `null`, the resource has no limit on the number of simultaneous bookings. */
            max_simultaneous_bookings?: number | null;
            /** @description Metadata associated with the resource. The client is free to fill this object with any valid JSON. */
            metadata?: Record<string, never> | null;
            /** @description Protected metadata associated with the resource. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /** @description Whether the resource is enabled. */
            enabled?: boolean;
        };
        /** Resource-service association */
        ResourceService: {
            /**
             * Format: uuid
             * @description The ID of the resource.
             */
            resource_id: string;
            /**
             * Format: uuid
             * @description The ID of the service.
             */
            service_id: string;
            /**
             * Format: date-time
             * @description The timestamp when the association between the resource and the service was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
        };
        /** Schedule block */
        ScheduleBlock: {
            /**
             * Format: uuid
             * @description The ID of the schedule block.
             */
            readonly id?: string;
            /**
             * Format: uuid
             * @description The ID of the location that the schedule block applies to.
             */
            location_id: string;
            /** @description The location that the schedule block applies to. */
            readonly location?: components["schemas"]["Location"];
            /**
             * Format: date-time
             * @description The timestamp when the schedule block starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the schedule block ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at: string;
            /**
             * @description Whether the resource is available for bookings at the location during this schedule block.
             * @default true
             */
            is_available: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the schedule block was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the schedule block was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Schedule block */
        ScheduleBlockPatch: {
            /**
             * Format: uuid
             * @description The ID of the location that the schedule block applies to.
             */
            location_id?: string;
            /**
             * Format: date-time
             * @description The timestamp when the schedule block starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            starts_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the schedule block ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            ends_at?: string;
            /** @description Whether the resource is available for bookings at the location during this schedule block. */
            is_available?: boolean;
        };
        /** Service */
        Service: components["schemas"]["ServiceFixed"] | components["schemas"]["ServiceFlexible"] | components["schemas"]["ServiceDay"];
        /** Service (prepended properties) */
        ServicePrepend: {
            /**
             * Format: uuid
             * @description The ID of the service.
             */
            readonly id?: string;
            /** @description The name of the service. */
            name: string;
            /**
             * @description The price of the service. For services with the type `fixed`, this is a fixed price. For services with the type `flexible`, this is the hourly rate. For services with the type `day`, this is the daily rate.
             * @default null
             */
            price: string | null;
            /**
             * @description The type of the service.
             *
             *     The type `fixed` is used for services that have a fixed time duration.
             *
             *     The type `flexible` is used for services that have a flexible time duration.
             *
             *     The type `day` is used for services that are booked by the day.
             * @enum {string}
             */
            type: "fixed" | "flexible" | "day";
        };
        /** Service (appended properties) */
        ServiceAppend: {
            /**
             * Format: duration
             * @description The buffer time required before the service. The buffer time will be taken into consideration when determining if a resource is available for a certain time span. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             * @default PT0S
             */
            buffer_time_before: string;
            /**
             * Format: duration
             * @description The buffer time required after this service. The buffer time will be taken into consideration when determining if a resource is available for a certain time span. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             * @default PT0S
             */
            buffer_time_after: string;
            /**
             * Format: duration
             * @description The start of the booking window for the service, i.e. the minimum duration required between the current timestamp and the start of a booking to be allowed to create it (or how near the start of a booking it is allowed to be created). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             * @default PT0S
             */
            booking_window_start: string;
            /**
             * Format: duration
             * @description The end of the booking window for the service, i.e. the maximum duration allowed between the current timestamp and the start of a booking to be allowed to create it (or how far into the future bookings are allowed to be created). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A duration of zero time is not allowed.
             *
             *     If this is `null`, there is no end to the booking window.
             * @default null
             */
            booking_window_end: string | null;
            /**
             * Format: duration
             * @description The cancelation threshold for the service, i.e. the minimum duration required between the current timestamp and the start of a booking to be allowed to cancel it (or how close to the start timestamp bookings are allowed to be canceled). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             * @default PT0S
             */
            cancelation_threshold: string;
            /**
             * @description Metadata associated with the service. The client is free to fill this object with any valid JSON.
             * @default null
             */
            metadata: Record<string, never> | null;
            /**
             * @description Protected metadata associated with the service. The client is free to fill this object with any valid JSON.
             * @default null
             */
            protected_metadata: Record<string, never> | null;
            /**
             * @description Whether the service is enabled.
             * @default true
             */
            enabled: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the service was created. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The timestamp when the service was last updated. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
             */
            readonly updated_at?: string;
        };
        /** Service (fixed) */
        ServiceFixed: components["schemas"]["ServicePrepend"] & {
            /**
             * Format: duration
             * @description The duration for the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A duration of zero time is not allowed.
             */
            duration: string;
            /**
             * Format: duration
             * @description The bookable interval for the service. Bookable slots for the service will be listed in this interval. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. For example, to get a bookable slot every 15 minutes, specify `PT15M`.
             *
             *     If this is `null`, the sum of the properties `duration`, `buffer_time_before`, and `buffer_time_after` will be used.
             * @default null
             */
            bookable_interval: string | null;
        } & components["schemas"]["ServiceAppend"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "fixed";
        };
        /** Service (flexible) */
        ServiceFlexible: components["schemas"]["ServicePrepend"] & {
            /**
             * Format: duration
             * @description The minimum duration allowed when booking the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A minimum duration of zero time is not allowed.
             */
            min_duration: string;
            /**
             * Format: duration
             * @description The maximum duration allowed when booking the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A maximum duration of zero time is not allowed.
             *
             *     If this is `null`, there is no upper limit for the duration.
             */
            max_duration: string | null;
            /**
             * Format: duration
             * @description The default duration for the service. This can be used for example to prefill forms for bookings for this service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. This must be greater than or equal to `min_duration`, and less than or equal to `max_duration` (if `max_duration` is not `null`).
             * @default null
             */
            default_duration: string | null;
            /**
             * Format: duration
             * @description The duration step allowed for the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            duration_step: string;
            /**
             * Format: duration
             * @description The bookable interval for the service. Bookable slots for the service will be listed in this interval. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. For example, to get a bookable slot every 15 minutes, specify `PT15M`.
             *
             *     If this is `null`, the value of the property `duration_step` will be used.
             * @default null
             */
            bookable_interval: string | null;
        } & components["schemas"]["ServiceAppend"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "flexible";
        };
        /** Service (day) */
        ServiceDay: components["schemas"]["ServicePrepend"] & {
            /**
             * Format: time
             * @description The start time for the service. This can either be a single time supplied as a string that will apply to every day of the week, or an object where the start time for each day of the week is supplied individually. A start date will be combined with this start time to form the start timestamp for a bookable slot. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            start_time: string | {
                /** Format: time */
                monday: string;
                /** Format: time */
                tuesday: string;
                /** Format: time */
                wednesday: string;
                /** Format: time */
                thursday: string;
                /** Format: time */
                friday: string;
                /** Format: time */
                saturday: string;
                /** Format: time */
                sunday: string;
            };
            /**
             * Format: time
             * @description The end time for the service. This can either be a single time supplied as a string that will apply to every day of the week, or an object where the end time for each day of the week is supplied individually. A end date will be combined with this end time to form the end timestamp for a bookable slot. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            end_time: string | {
                /** Format: time */
                monday: string;
                /** Format: time */
                tuesday: string;
                /** Format: time */
                wednesday: string;
                /** Format: time */
                thursday: string;
                /** Format: time */
                friday: string;
                /** Format: time */
                saturday: string;
                /** Format: time */
                sunday: string;
            };
            /** @description The minimum number of days allowed when booking the service. If this is `1`, bookings with the same start and end date will be allowed, but only if `end_time` is after `start_time`. */
            min_days: number;
            /** @description The maximum number of days allowed when booking the service. If this is `1`, only bookings with the same start and end date will be allowed, but only if `end_time` is after `start_time`. If this is `null`, there is no upper limit on the number of days for a booking. If not `null`, this must be greater than or equal to `min_days`. */
            max_days: number | null;
            /**
             * @description The default number of days for the service. This can be used for example to prefill forms for bookings for this service. This must be greater than or equal to `min_days`, and less than or equal to `max_days` (if `max_days` is not `null`).
             * @default null
             */
            default_days: number | null;
        } & components["schemas"]["ServiceAppend"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "day";
        };
        /** Service */
        ServicePatch: components["schemas"]["ServiceFixedPatch"] | components["schemas"]["ServiceFlexiblePatch"] | components["schemas"]["ServiceDayPatch"];
        /** Service (patch, prepended properties) */
        ServicePrependPatch: {
            /** @description The name of the service. */
            name?: string;
            /** @description The price of the service. For services with the type `fixed`, this is a fixed price. For services with the type `flexible`, this is the hourly rate. For services with the type `day`, this is the daily rate. */
            price?: string | null;
            /**
             * @description The type of the service.
             *
             *     The type `fixed` is used for services that have a fixed time duration.
             *
             *     The type `flexible` is used for services that have a flexible time duration.
             *
             *     The type `day` is used for services that are booked by the day.
             * @enum {string}
             */
            type?: "fixed" | "flexible" | "day";
        };
        /** Service (patch, appended properties) */
        ServiceAppendPatch: {
            /**
             * Format: duration
             * @description The buffer time required before the service. The buffer time will be taken into consideration when determining if a resource is available for a certain time span. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            buffer_time_before?: string;
            /**
             * Format: duration
             * @description The buffer time required after this service. The buffer time will be taken into consideration when determining if a resource is available for a certain time span. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            buffer_time_after?: string;
            /**
             * Format: duration
             * @description The start of the booking window for the service, i.e. the minimum duration required between the current timestamp and the start of a booking to be allowed to create it (or how near the start of a booking it is allowed to be created). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            booking_window_start?: string;
            /**
             * Format: duration
             * @description The end of the booking window for the service, i.e. the maximum duration allowed between the current timestamp and the start of a booking to be allowed to create it (or how far into the future bookings are allowed to be created). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A duration of zero time is not allowed.
             *
             *     If this is `null`, there is no end to the booking window.
             */
            booking_window_end?: string | null;
            /**
             * Format: duration
             * @description The cancelation threshold for the service, i.e. the minimum duration required between the current timestamp and the start of a booking to be allowed to cancel it (or how close to the start timestamp bookings are allowed to be canceled). This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            cancelation_threshold?: string;
            /**
             * @description Metadata associated with the service. The client is free to fill this object with any valid JSON.
             * @default null
             */
            metadata: Record<string, never> | null;
            /** @description Protected metadata associated with the service. The client is free to fill this object with any valid JSON. */
            protected_metadata?: Record<string, never> | null;
            /** @description Whether the service is enabled. */
            enabled?: boolean;
        };
        /** Service (fixed) */
        ServiceFixedPatch: components["schemas"]["ServicePrependPatch"] & {
            /**
             * Format: duration
             * @description The duration for the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A duration of zero time is not allowed.
             */
            duration?: string;
            /**
             * Format: duration
             * @description The bookable interval for the service. Bookable slots for the service will be listed in this interval. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. For example, to get a bookable slot every 15 minutes, specify `PT15M`.
             *
             *     If this is `null`, the sum of the properties `duration`, `buffer_time_before`, and `buffer_time_after` will be used.
             */
            bookable_interval?: string | null;
        } & components["schemas"]["ServiceAppendPatch"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "fixed";
        };
        /** Service (flexible) */
        ServiceFlexiblePatch: components["schemas"]["ServicePrependPatch"] & {
            /**
             * Format: duration
             * @description The minimum duration allowed when booking the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A minimum duration of zero time is not allowed.
             */
            min_duration?: string;
            /**
             * Format: duration
             * @description The maximum duration allowed when booking the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A maximum duration of zero time is not allowed.
             *
             *     If this is `null`, there is no upper limit for the duration.
             */
            max_duration?: string | null;
            /**
             * Format: duration
             * @description The default duration for the service. This can be used for example to prefill forms for bookings for this service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. This must be greater than or equal to `min_duration`, and less than or equal to `max_duration` (if `max_duration` is not `null`).
             * @default null
             */
            default_duration: string | null;
            /**
             * Format: duration
             * @description The duration step allowed for the service. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions.
             */
            duration_step?: string;
            /**
             * Format: duration
             * @description The bookable interval for the service. Bookable slots for the service will be listed in this interval. This is formatted in the ISO 8601 format for durations: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. For example, to get a bookable slot every 15 minutes, specify `PT15M`.
             *
             *     If this is `null`, the value of the property `duration_step` will be used.
             */
            bookable_interval?: string | null;
        } & components["schemas"]["ServiceAppendPatch"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "flexible";
        };
        /** Service (day) */
        ServiceDayPatch: components["schemas"]["ServicePrependPatch"] & {
            /**
             * Format: time
             * @description The start time for the service. This can either be a single time supplied as a string that will apply to every day of the week, or an object where the start time for each day of the week is supplied individually. A start date will be combined with this start time to form the start timestamp for a bookable slot. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            start_time?: string | {
                /** Format: time */
                monday: string;
                /** Format: time */
                tuesday: string;
                /** Format: time */
                wednesday: string;
                /** Format: time */
                thursday: string;
                /** Format: time */
                friday: string;
                /** Format: time */
                saturday: string;
                /** Format: time */
                sunday: string;
            };
            /**
             * Format: time
             * @description The end time for the service. This can either be a single time supplied as a string that will apply to every day of the week, or an object where the end time for each day of the week is supplied individually. A end date will be combined with this end time to form the end timestamp for a bookable slot. This time is formatted in ISO 8601 format: `hh:mm:ss`.
             */
            end_time?: string | {
                /** Format: time */
                monday: string;
                /** Format: time */
                tuesday: string;
                /** Format: time */
                wednesday: string;
                /** Format: time */
                thursday: string;
                /** Format: time */
                friday: string;
                /** Format: time */
                saturday: string;
                /** Format: time */
                sunday: string;
            };
            /** @description The minimum number of days allowed when booking the service. If this is `1`, bookings with the same start and end date will be allowed, but only if `end_time` is after `start_time`. */
            min_days?: number;
            /** @description The maximum number of days allowed when booking the service. If this is `1`, only bookings with the same start and end date will be allowed, but only if `end_time` is after `start_time`. If this is `null`, there is no upper limit on the number of days for a booking. If not `null`, this must be greater than or equal to `min_days`. */
            max_days?: number | null;
            /**
             * @description The default number of days for the service. This can be used for example to prefill forms for bookings for this service. This must be greater than or equal to `min_days`, and less than or equal to `max_days` (if `max_days` is not `null`).
             * @default null
             */
            default_days: number | null;
        } & components["schemas"]["ServiceAppendPatch"] & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "day";
        };
    };
    responses: {
        /** @description A `422 Unprocessable Entity` response is returned if the request contains some kind of validation error. */
        UnprocessableEntity: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ValidationError"];
            };
        };
        /** @description A `422 Unprocessable Entity` response is returned if the request contains some kind of validation error. */
        BookingGroupUnprocessableEntity: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ValidationError"] | components["schemas"]["BookingGroupError"];
            };
        };
        /** @description A `403 Forbidden` response is returned if the API token used for authorization does not have the required ability. */
        Forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        /** @description The page number to retrieve. */
        page: number;
        /** @description The number of items per page. */
        per_page: number;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getBookings: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve bookings that end after this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. If provided, this must be less than or equal to `to`. */
                from?: string;
                /** @description Retrieve bookings that start before this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. If provided, this must be greater than or equal to `from`. */
                to?: string;
                /** @description The ID of a resource to retrieve bookings for. */
                resource?: string;
                /** @description The ID of a service to retrieve bookings for. */
                service?: string;
                /** @description The ID of a location to retrieve bookings for. */
                location?: string;
                /** @description Whether to exclude, include, or only retrieve temporary bookings. */
                temporary?: "exclude" | "include" | "only";
                /** @description Whether to exclude, include, or only retrieve canceled bookings. */
                canceled?: "exclude" | "include" | "only";
                /** @description Filter the bookings by their price. */
                "price[{operator}]"?: string;
                /** @description Filter the bookings by their starts at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "starts_at[{operator}]"?: string;
                /** @description Filter the bookings by their ends at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "ends_at[{operator}]"?: string;
                /** @description Filter the bookings by their buffer starts at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "buffer_starts_at[{operator}]"?: string;
                /** @description Filter the bookings by their buffer ends at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "buffer_ends_at[{operator}]"?: string;
                /** @description Filter the bookings by their metadata values. */
                "metadata[{property}][{operator}]"?: string;
                /** @description Filter the bookings by their protected metadata values. */
                "protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the bookings by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the bookings by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Filter the bookings by their finalized at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "finalized_at[{operator}]"?: string;
                /** @description Filter the bookings by their canceled at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "canceled_at[{operator}]"?: string;
                /** @description Sort the bookings by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "starts_at.asc" | "starts_at.desc" | "ends_at.asc" | "ends_at.desc" | "buffer_starts_at.asc" | "buffer_starts_at.desc" | "buffer_ends_at.asc" | "buffer_ends_at.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of bookings. If no bookings matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Booking"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postBooking: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingPost"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created booking. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Booking"];
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getBooking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking. */
                booking: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified booking exists. The response body contains the retrieved booking. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Booking"];
                    "application/xml": Record<string, never>;
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified booking doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putBooking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking. */
                booking: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingPut"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the booking was replaced successfully. The response body contains the booking. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Booking"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteBooking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking. */
                booking: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the booking was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchBooking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking. */
                booking: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingPatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the booking was patched successfully. The response body contains the patched booking. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Booking"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getBookingGroups: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve booking groups that include bookings that end after this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. If provided, this must be less than or equal to `to`. */
                from?: string;
                /** @description Retrieve booking groups that include bookings that start before this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. If provided, this must be greater than or equal to `from`. */
                to?: string;
                /** @description Retrieve booking groups that include bookings for this resource. */
                resource?: string;
                /** @description Retrieve booking groups that include bookings for this service. */
                service?: string;
                /** @description Retrieve booking groups that include bookings for this location. */
                location?: string;
                /** @description Whether to exclude, include, or only retrieve booking groups that include temporary bookings. */
                temporary?: "exclude" | "include" | "only";
                /** @description Whether to exclude, include, or only retrieve booking groups that include canceled bookings. */
                canceled?: "exclude" | "include" | "only";
                /** @description Filter the booking groups by the price of the included bookings. */
                "price[{operator}]"?: string;
                /** @description Filter the booking groups by the starts at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "starts_at[{operator}]"?: string;
                /** @description Filter the booking groups by the ends at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "ends_at[{operator}]"?: string;
                /** @description Filter the booking groups by the buffer starts at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "buffer_starts_at[{operator}]"?: string;
                /** @description Filter the booking groups by the buffer ends at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "buffer_ends_at[{operator}]"?: string;
                /** @description Filter the booking groups by the metadata values of the included bookings. */
                "metadata[{property}][{operator}]"?: string;
                /** @description Filter the booking groups by the protected metadata values of the included bookings. */
                "protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the booking groups by the created at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the booking groups by the updated at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Filter the booking groups by the finalized at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "finalized_at[{operator}]"?: string;
                /** @description Filter the booking groups by the canceled at timestamp of the included bookings. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "canceled_at[{operator}]"?: string;
                /** @description Filter the booking groups by their metadata values. */
                "group_metadata[{property}][{operator}]"?: string;
                /** @description Filter the booking groups by their protected metadata values. */
                "group_protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the booking groups by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "group_created_at[{operator}]"?: string;
                /** @description Filter the booking groups by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "group_updated_at[{operator}]"?: string;
                /** @description Sort the booking groups by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "starts_at.asc" | "starts_at.desc" | "ends_at.asc" | "ends_at.desc" | "buffer_starts_at.asc" | "buffer_starts_at.desc" | "buffer_ends_at.asc" | "buffer_ends_at.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of booking groups. If no booking groups matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["BookingGroup"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postBookingGroup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingGroupPost"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created booking group. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingGroup"];
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["BookingGroupUnprocessableEntity"];
        };
    };
    getBookingGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking group. */
                "booking-group": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified booking group exists. The response body contains the retrieved booking group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingGroup"];
                    "application/xml": Record<string, never>;
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified booking group doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putBookingGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking group. */
                "booking-group": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingGroupPut"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the booking group was replaced successfully. The response body contains the booking group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingGroup"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking group doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["BookingGroupUnprocessableEntity"];
        };
    };
    deleteBookingGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking group. */
                "booking-group": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the booking group was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking group doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchBookingGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a booking group. */
                "booking-group": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BookingGroupPatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the booking group was patched successfully. The response body contains the patched booking group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingGroup"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the booking group doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["BookingGroupUnprocessableEntity"];
        };
    };
    getLocations: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Whether to exclude, include, or only retrieve disabled locations. */
                disabled?: "exclude" | "include" | "only";
                /** @description Filter the locations by their name. */
                "name[{operator}]"?: string;
                /** @description Filter the locations by their time zone. The time zone must be valid according to the IANA time zone database. */
                timezone?: string;
                /** @description Filter the locations by their resource selection strategy. */
                resource_selection_strategy?: "randomize" | "prioritize" | "equalize";
                /** @description Filter the locations by their metadata values. */
                "metadata[{property}][{operator}]"?: string;
                /** @description Filter the locations by their protected metadata values. */
                "protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the locations by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the locations by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the locations by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "name.asc" | "name.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of locations. If no locations matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Location"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postLocation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Location"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created location. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Location"];
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getLocation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a location. */
                location: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified location exists. The response body contains the retrieved location. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Location"];
                    "application/xml": Record<string, never>;
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified location doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putLocation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a location. */
                location: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Location"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the location was replaced successfully. The response body contains the location. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Location"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the location doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteLocation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a location. */
                location: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the location was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the location doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchLocation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a location. */
                location: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["LocationPatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the location was patched successfully. The response body contains the patched location. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Location"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the location doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getYourProject: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the API token of the request is associated with a project. The response body contains the retrieved project. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Project"];
                };
            };
            /** @description A `404 Not Found` response is returned if the API token is not associated with a project. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getResources: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Whether to exclude, include, or only retrieve disabled resources. */
                disabled?: "exclude" | "include" | "only";
                /** @description Filter the resources by their name. */
                "name[{operator}]"?: string;
                /** @description Filter the resources by their max simultaneous bookings. */
                "max_simultaneous_bookings[{operator}]"?: number;
                /** @description Filter the resources by their metadata values. */
                "metadata[{property}][{operator}]"?: string;
                /** @description Filter the resources by their protected metadata values. */
                "protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the resources by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the resources by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the resources by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "name.asc" | "name.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of resources. If no resources matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Resource"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postResource: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Resource"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created resource. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Resource"];
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource exists. The response body contains the retrieved resource. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Resource"];
                    "application/xml": Record<string, never>;
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Resource"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the resource was replaced successfully. The response body contains the resource. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Resource"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the resource was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourcePatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the resource was patched successfully. The response body contains the patched resource. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Resource"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceScheduleBlocks: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve schedule blocks that end after this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be less than or equal to `to`. */
                from?: string;
                /** @description Retrieve schedule blocks that start before this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be greater than or equal to `from`. */
                to?: string;
                /** @description The ID of a location. When this is provided, only schedule blocks for this location will be retrieved. */
                location?: string;
                /** @description Filter the schedule blocks by their starts at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "starts_at[{operator}]"?: string;
                /** @description Filter the schedule blocks by their ends at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "ends_at[{operator}]"?: string;
                /** @description Filter the schedule blocks by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the schedule blocks by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the schedule blocks by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "starts_at.asc" | "starts_at.desc" | "ends_at.asc" | "ends_at.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of schedule blocks. If no schedule blocks matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ScheduleBlock"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postResourceScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ScheduleBlock"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created schedule block. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource and schedule block exists. The response body contains the retrieved schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or schedule block doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putResourceScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ScheduleBlock"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the schedule block was replaced successfully. The response body contains the schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or schedule block doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteResourceScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the schedule block was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or schedule block doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchResourceScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ScheduleBlockPatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the schedule block was patched successfully. The response body contains the patched schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or schedule block doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceRecurringSchedules: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve recurring schedules that expire at or after this date. This date is formatted in ISO 8601 format: `YYYY-MM-DD`. If provided, this must be less than or equal to `to`. */
                from?: string;
                /** @description Retrieve recurring schedules that take effect at or before this date. This date is formatted in ISO 8601 format: `YYYY-MM-DD`. If provided, this must be greater than or equal to `from`. */
                to?: string;
                /** @description The ID of a location. When this is provided, only recurring schedules for this location will be retrieved. */
                location?: string;
                /** @description Filter the recurring schedules by their start date. This date is formatted in ISO 8601 format: `YYYY-MM-DD`. */
                "start_date[{operator}]"?: string;
                /** @description Filter the recurring schedules by their end date. This date is formatted in ISO 8601 format: `YYYY-MM-DD`. */
                "end_date[{operator}]"?: string;
                /** @description Filter the recurring schedules by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the recurring schedules by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the recurring schedules by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "start_date.asc" | "start_date.desc" | "end_date.asc" | "end_date.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of recurring schedules. If no recurring schedules matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["RecurringSchedule"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postResourceRecurringSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringSchedule"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created recurring schedule. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringSchedule"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceRecurringSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource and recurring schedule exists. The response body contains the retrieved recurring schedule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringSchedule"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putResourceRecurringSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringSchedule"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the recurring schedule was replaced successfully. The response body contains the recurring schedule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringSchedule"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteResourceRecurringSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the recurring schedule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchResourceRecurringSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringSchedulePatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the recurring schedule was patched successfully. The response body contains the patched recurring schedule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringSchedule"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceRecurringScheduleBlocks: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Filter the recurring schedule blocks by their weekday. */
                weekday?: "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
                /** @description Filter the recurring schedule blocks by their start time. This time is formatted in ISO 8601 format: `hh:mm:ss`. */
                "start_time[{operator}]"?: string;
                /** @description Filter the recurring schedule blocks by their end time. This time is formatted in ISO 8601 format: `hh:mm:ss`. */
                "end_time[{operator}]"?: string;
                /** @description Filter the recurring schedule blocks by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the recurring schedule blocks by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the recurring schedule blocks by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. Weekdays are sorted by their weekday number according to ISO 8601, with Monday being 1 and Sunday being 7. */
                sort?: "weekday.asc" | "weekday.desc" | "start_time.asc" | "start_time.desc" | "end_time.asc" | "end_time.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of recurring schedule blocks. If no recurring schedule blocks matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["RecurringScheduleBlock"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postResourceRecurringScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringScheduleBlock"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created recurring schedule block. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or recurring schedule doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceRecurringScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
                /** @description The ID of a recurring schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource, recurring schedule, and recurring schedule block exists. The response body contains the retrieved recurring schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource, recurring schedule, or recurring schedule block  doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putResourceRecurringScheduleScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
                /** @description The ID of a recurring schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringScheduleBlock"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the recurring schedule block was replaced successfully. The response body contains the recurring schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource, recurring schedule, or recurring schedule block  doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteResourceRecurringScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
                /** @description The ID of a recurring schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the recurring schedule block was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource, recurring schedule, or recurring schedule block  doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchResourceRecurringScheduleScheduleBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a recurring schedule. */
                "recurring-schedule": string;
                /** @description The ID of a recurring schedule block. */
                "schedule-block": string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecurringScheduleBlockPatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the recurring schedule block was patched successfully. The response body contains the patched recurring schedule block. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecurringScheduleBlock"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource, recurring schedule, or recurring schedule block  doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceSchedule: {
        parameters: {
            query: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve the schedule from this timestamp onwards. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be less than `to`. */
                from: string;
                /** @description Retrieve the schedule up until this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be greater than `from`. */
                to: string;
                /** @description The ID of a location to retrieve the schedule for. */
                location: string;
                /** @description Whether to exclude or include time spans when the resource is fully booked. */
                fully_booked?: "exclude" | "include";
            };
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of time spans. If no time spans matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /**
                             * Format: date-time
                             * @description The timestamp when the time span starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
                             */
                            readonly starts_at?: string;
                            /**
                             * Format: date-time
                             * @description The timestamp when the time span ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
                             */
                            readonly ends_at?: string;
                        }[];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceFullyBooked: {
        parameters: {
            query: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve the fully booked time spans from this timestamp onwards. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be less than `to`. */
                from: string;
                /** @description Retrieve the fully booked time spans up until this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be greater than `from`. */
                to: string;
            };
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of time spans. If no time spans matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /**
                             * Format: date-time
                             * @description The timestamp when the time span starts. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
                             */
                            readonly starts_at?: string;
                            /**
                             * Format: date-time
                             * @description The timestamp when the time span ends. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`.
                             */
                            readonly ends_at?: string;
                        }[];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getResourceServices: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains an array of service associations for the resource. If no associations exist, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"][];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getResourceService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified service and resource exists, and they are associated with each other. The response body contains the retrieved association. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service or resource doesn’t exist, or if they aren’t associated with each other. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putResourceService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified service is already associated with the resource. The response body contains the existing association. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            /** @description A `201 Created` response is returned if the specified service was associated with the resource successfully. The response body contains the created association. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service or resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteResourceService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a resource. */
                resource: string;
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the service was dissociated from the resource successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service or resource doesn’t exist, or if they aren’t associated with each other. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getServices: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Whether to exclude, include, or only retrieve disabled services. */
                disabled?: "exclude" | "include" | "only";
                /** @description Filter the services by their name. */
                "name[{operator}]"?: string;
                /** @description Filter the services by their price. */
                "price[{operator}]"?: string;
                /** @description Filter the services by their type. */
                type?: "fixed" | "flexible" | "day";
                /** @description Filter the services by their metadata values. */
                "metadata[{property}][{operator}]"?: string;
                /** @description Filter the services by their protected metadata values. */
                "protected_metadata[{property}][{operator}]"?: string;
                /** @description Filter the services by their created at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "created_at[{operator}]"?: string;
                /** @description Filter the services by their updated at timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. */
                "updated_at[{operator}]"?: string;
                /** @description Sort the services by these properties and orders. Multiple sorts can be combined with a comma between them, and will be applied in the given order. */
                sort?: "name.asc" | "name.desc" | "created_at.asc" | "created_at.desc" | "updated_at.asc" | "updated_at.desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains a pagination object with an array of services. If no services matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Service"][];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    postService: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Service"];
            };
        };
        responses: {
            /** @description A `201 Created` response is returned if there were no errors with the request. The response body contains the created service. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Service"];
                };
            };
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified service exists. The response body contains the retrieved service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Service"];
                    "application/xml": Record<string, never>;
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Service"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the service was replaced successfully. The response body contains the service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Service"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    deleteService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the service was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    patchService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ServicePatch"];
            };
        };
        responses: {
            /** @description A `200 OK` response is returned if the service was patched successfully. The response body contains the patched service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Service"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getServiceBookableSlots: {
        parameters: {
            query: {
                /** @description The page number to retrieve. */
                page?: components["parameters"]["page"];
                /** @description The number of items per page. */
                per_page?: components["parameters"]["per_page"];
                /** @description Retrieve bookable slots from this timestamp onwards. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be less than `to`. */
                from: string;
                /** @description Retrieve bookable slots up until this timestamp. This timestamp is formatted in ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`. This must be greater than `from`. */
                to: string;
                /** @description The ID of a location to retrieve the bookable slots for. */
                location: string;
                /** @description The ID of a resource to retrieve bookable slots for. If this is not provided, bookable slots for all available resources will be retrieved. */
                resource?: string;
                /** @description Whether to ignore the booking window of the service. */
                ignore_booking_window?: "true" | "false";
                /** @description Only applicable to services of type `flexible` and `day`. A duration that the bookable slots must be able to fit. This is formatted in the ISO 8601 format for duration: `P[n]Y[n]M[n]DT[n]H[n]M[n]S` or `P[n]W`, with a maximum of 4 digits per element and no decimal fractions. A duration of zero time is not allowed. */
                duration?: string;
                /** @description The minimum number of resources that must be available for the bookable slots. */
                num_resources?: number;
            };
            header?: never;
            path: {
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains an array of bookable slots. If no bookable slots matched the query parameters, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: (components["schemas"]["BookableSlotFixed"] | components["schemas"]["BookableSlotFlexible"] | components["schemas"]["BookableSlotDay"])[];
                        links?: {
                            /**
                             * Format: uri
                             * @description The URL to the first page of the paginated result.
                             */
                            first?: string;
                            /**
                             * Format: uri
                             * @description The URL to the last page of the paginated result.
                             */
                            last?: string;
                            /**
                             * Format: uri
                             * @description The URL to the previous page of the paginated result.
                             */
                            prev?: string | null;
                            /**
                             * Format: uri
                             * @description The URL to the next page of the paginated result.
                             */
                            next?: string | null;
                        };
                        meta?: {
                            /** @description The current page number. */
                            current_page?: number;
                            /** @description The index of the first item on this page. */
                            from?: number | null;
                            /** @description The last page number. */
                            last_page?: number;
                            /**
                             * Format: uri
                             * @description The URL of the paginated result (excluding the query string).
                             */
                            path?: string;
                            /** @description The maximum number of items per page. */
                            per_page?: number;
                            /** @description The index of the last item of this page. */
                            to?: number | null;
                            /** @description The total number of items in the paginated result. */
                            total?: number;
                        };
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service, location, or resource doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getServiceResources: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                service: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if there were no errors with the request. The response body contains an array of resource associations for the service. If no associations exist, the array will be empty. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"][];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getServiceResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource and service exists, and they are associated with each other. The response body contains the retrieved association. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or service doesn’t exist, or if they aren’t associated with each other. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    putServiceResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `200 OK` response is returned if the specified resource is already associated with the service. The response body contains the existing association. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            /** @description A `201 Created` response is returned if the specified resource was associated with the service successfully. The response body contains the created association. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceService"];
                };
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or service doesn’t exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteServiceResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of a service. */
                service: string;
                /** @description The ID of a resource. */
                resource: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A `204 No Content` response is returned if the resource was dissociated from the service successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["Forbidden"];
            /** @description A `404 Not Found` response is returned if the specified resource or service doesn’t exist, or if they aren’t associated with each other. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
